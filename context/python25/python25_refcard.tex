\startproduct python25/python25_refcard
\project project

\StartRefcard

\RefcardTitle{Python 2.5 Reference Card}

\useurl[mail][mailto:goerz@physik.fu-berlin.de][][<goerz@physik.fu-berlin.de>] 
\useurl[homepage][http://michaelgoerz.net][][http://michaelgoerz.net] 
\useurl[creativecommons][http://creativecommons.org/license][][http://creativecommons.org/license] 

\copyright 2011 Michael Goerz \from[mail]\\
Web: \from[homepage] \\
This work is licensed under the Creative Commons
Attribution-Noncommercial-Share Alike 3.0 License. To view a copy of this
license, visit \from[creativecommons].


\section{Variable Types}

\subsection{Numbers}
\RefLn{{\tt 42 052 0x2A 42L 052L 0x2AL} }{42 (dec, oct, hex, short/long)   }
\RefLn{{\tt 0.2  .8  4.  1.e10  1.0e-7 }}{floating point value             }
\RefLn{{\tt z = 5.0 – 2.0J; }           }{complex number                   }
\RefLn{{\tt z = complex(real, imag)}    }{complex number                   }
\RefLn{{\tt z.real; z.imag}             }{real and imag part of z          }
\RefLn{{\tt True; False}                }{constants for boolean values     }
\RefLn{{\tt abs(n)}                     }{absolute value of n              }
\RefLn{{\tt divmod(x, y)}               }{{\tt (x/y, x\%y})                }
\RefLn{{\tt hex(n)}                     }{create hex string                }
\RefLn{{\tt oct(n)}                     }{create octal string              }
\RefLn{{\tt ord(c)}                     }{unicode code point of char       }
\RefLn{{\tt round(x,n)}                 }{round x to n decimal places      }
\RefLn{{\tt cmp(x,y)}                   }{{\tt x<y: -1,  x==y: 0,  x>y: 1} }
\RefLn{{\tt coerce(x, y)}               }{{\tt (x,y)}, make same type      }
\RefLn{{\tt pow(x,y,z)}                 }{{\tt (x**y) \% z}                }
\RefLn{{\tt float("3.14")}              }{float from string                }
\RefLn{{\tt int("42", base)}            }{int from string                  }
\RefLn{{\tt import math; import cmath}  }{more math functions              }
\RefLn{{\tt import random}              }{random number generators         }


\subsection{Sequences}
\RefLn{{\tt s=l=[1,"bla",[1+2J,1.4],4]}      }{list creation                           }
\RefLn{{\tt s=t=(1,"bla",[1+2J,1.4],4)}      }{tuple creation                          }
\RefLn{{\tt l=list(t); t=tuple(l)}           }{list/tuple conversion                   }
\RefLn{{\tt l=range(1000)}                   }{list of integers (0-999)                }
\RefLn{{\tt s2=xrange(1000)}                 }{immut. xrange-sequence                  }
\RefLn{{\tt i=iter(s); i.next()}             }{iterator from sequence                  }
\RefLn{{\tt s[2][0]}                         }{get list element {\tt (1+2J)}           }
\RefLn{{\tt s[-2][-1]}                       }{get list element {\tt (1.4)}            }
\RefLn{{\tt s1+s1}                           }{sequence concat                         }
\RefLn{{\tt n*s1}                            }{repeat {\tt s1} {\tt n} times           }
\RefLn{{\tt s[i:j]; s[i:]; s[:j]}            }{slicing ({\tt i} incl., {\tt j} excl.)  }
\RefLn{{\tt s[i:j:k]}                        }{slice with stride {\tt k}               }
\RefLn{{\tt s[::2]; s[::-1]}                 }{every 2nd Element/reverse {\tt s}     }
\RefLn{{\tt x in s; x not in s}              }{is {\tt x} a member of {\tt s}?         }
\RefLn{{\tt len(s)}                          }{number of elements                      }
\RefLn{{\tt min(s); max(s)}                  }{min/max                                 }
\RefLn{{\tt l[i:j]=['a','b','c','d']}        }{replace slice                           }
\RefLn{{\tt l[i:i]=['a','b']}                }{insert before position {\tt i}          }
\RefLn{{\tt l.count(x)}                      }{number of occurances of {\tt x}         }
\RefLn{{\tt l.index(x)}                      }{first index of {\tt x}, or error        }
\RefLn{{\tt l.append(x)}                     }{append {\tt x} at end of {\tt l}        }
\RefLn{{\tt x=l.pop()}                       }{pop off last element                    }
\RefLn{{\tt l.extend(l2)}                    }{append {\tt l2} at end of {\tt l}       }
\RefLn{{\tt l.insert(i,x)}                   }{instert {\tt x} at pos. {\tt i}         }
\RefLn{{\tt l.remove(x)}                     }{delete first {\tt x}                    }
\RefLn{{\tt l.reverse()}                     }{reverse {\tt l}                         }
\RefLn{{\tt l.sort(f)}                       }{sort using {\tt f} (default {\tt f=cmp})}
\RefLn{{\tt zip(s,t,...)}                    }{{\tt [(s[0],t[0],...),..]}              }

\subsection{Dictionary (Mappings)}
\RefLn{{\tt d={'x':42,'y':3.14,'z':7}}       }{dict creation                           }
\RefLn{{\tt d['x']}                          }{get entry for {\tt x}                   }
\RefLn{{\tt len(d)}                          }{number of keys                          }
\RefLn{{\tt del(d['x'])}                     }{delete entry from dict                  }
\RefLn{{\tt d.copy()}                        }{create shallow copy                     }
\RefLn{{\tt d.has\_key(k)}                   }{does key exist?                         }
\RefLn{{\tt d.items()}                       }{list of all items                       }
\RefLn{{\tt d.keys()}                        }{list of all keys                        }
\RefLn{{\tt d.values()}                      }{list of all values                      }
\RefLn{{\tt i=d.iteritems(); i.next()}       }{iterator over items                     }
\RefLn{{\tt i=d.iterkeys(); i.next()}        }{iterator over keys                      }
\RefLn{{\tt i=d.itervalues(); i.next()}      }{iterator over values                    }
\RefLn{{\tt d.get(k,x)}                      }{get entry for {\tt k}, or return {\tt x}}
\RefLn{{\tt d.clear()}                       }{remove all items                        }
\RefLn{{\tt d.setdefault(k,x)}               }{return {\tt d[k]} or set {\tt d[k]=x}   }
\RefLn{{\tt d.popitem()}                     }{return and delete an item               }


\subsection{Sets}
\RefLn{{\tt s=set(s); fs=frozenset(s)}       }{create set                              }
\RefLn{{\tt fs.issubset(t); s<=t}            }{all {\tt s} in {\tt t}?                 }
\RefLn{{\tt fs.issuperset(t); s>=t}          }{all {\tt t} in {\tt s}?                 }
\RefLn{{\tt fs.union(t); s\textbar{}t}       }{all elements from {\tt s} and {\tt t}   }
\RefLn{{\tt fs.intersection(t); s\&t}        }{elements both in {\tt s} and {\tt t}    }
\RefLn{{\tt fs.difference(t); s-t}           }{all {\tt s} not in {\tt t}              }
\RefLn{{\tt fs.symmetric\_difference(t);s\^t}}{all either {\tt s} or {\tt t}           }
\RefLn{{\tt fs.copy()}                       }{shallow copy of {\tt s}                 }
\RefLn{{\tt s.update(t); s\textbar{}=t}      }{add elements of {\tt t}                 }
\RefLn{{\tt s.intersection\_update(t); s\&=t}}{keep only what is also in {\tt t}       }
\RefLn{{\tt s.difference\_update(t); s-=t}   }{remove elements of {\tt t}              }
\RefLn{{\tt s.symmetric\_differ...(t); s\^=t}}{keep only symm. difference              }
\RefLn{{\tt s.add(x)}                        }{add {\tt x} to {\tt fs}                 }
\RefLn{{\tt s.remove(x); fs.discard(x);}     }{remove {\tt x} (/ with exception)       }
\RefLn{{\tt s.pop();}                        }{return and remove any elem.             }
\RefLn{{\tt s.clear();}                      }{remove all elements                     }



\subsection{Strings and Regular Expressions}
\RefLn{{\tt "bla"; 'hello "world"'}          }{string (of bytes)                     }
\RefLn{{\tt """bla""", '''bla'''}            }{triple quotes for multiline           }
\RefLn{{\tt \bs ~~~ \bs\bs ~~~ \bs{}0}       }{cont., backslash, null char           }
\RefLn{{\tt \bs{}N{id} \bs{}uhhhh \bs{}Uhhhhhhhh} }{unicode char                     }
\RefLn{{\tt \bs{}xhh \bs{}ooo}               }{hex, octal byte                       }
\RefLn{{\tt u"Ünic\bs{}u00F8de"; u"\bs{}xF8"}}{unicode string (of chars)        }
\RefLn{{\tt r"C:\bs{}new\bs{}text.dat"; ur"\bs\bs{}Ü"} }{raw string (unicode)        }
\RefLn{{\tt str(3.14); str(42)}              }{string conversion                     }
\RefLn{{\tt "\bs{}\%s-\bs{}\%s-\bs{}\%s" \% (42,3.14,[1,2,3])}  }{string formatting  }
\RefLn{{\tt '\bs{}t'.join(seq)}              }{join seq.\ with separator         }
\RefLn{{\tt s.decode('utf-8')}               }{latin-1 string to  unicode string     }
\RefLn{{\tt u.encode('utf-8')}               }{unicode string to utf-8  string       }
\RefLn{{\tt chr(i), unichr(i)}               }{char from code point                  }
\RefLn{{\tt str(x)}                          }{string from number/object             }

{\bf Other String Methods:}
%=========================

{\it search and replace:} {\tt find(s,b,e), rfind(s,b,e), index(s,b,e), rindex(s,b,e), count(s,b,e), endswith(s,b,e), startswith(s,b,e), replace(o,n,m)};
{\it formatting:} {\tt capitalize, lower, upper, swapcase, title};
{\it splitting:} {\tt partition(s), rpartition(s), split(s,m), rsplit(s,m), splitlines(ke)};
{\it padding:} {\tt center(w,c), ljust(w,c), lstrip(cs), rjust(w,c), rstrip(cs), strip(cs), zfill(w), expandtabs(ts)};
{\it checking:} {\tt isalnum, isalpha, isdigit, islower, isspace, istitle, isupper};
{\it String Constants} ({\tt import string}):
{\tt digits, hexdigits, letters, lowercase, octdigits, printable,
punctuation, uppercase, whitespace}

{Regexes:} {\tt import re}

\RefLn{{\tt r=re.compile(r'rx',re.ILMSUX)} }{comile {\tt 'rx'} as regex                    }
\RefLn{{\tt (?P<id>...)}                   }{named group                                   }
\RefLn{{\tt m=r.match(s,b,e)}              }{full match                                    }
\RefLn{{\tt re.match(r'(?iLmsux)rx',s)}    }{direct regex usage                            }
\RefLn{{\tt m=r.search(s,b,e)}             }{partial match                                 }
\RefLn{{\tt l=r.split(s,ms)}               }{split and return list                         }
\RefLn{{\tt l=r.findall(string)}           }{list of all matched groups                    }
\RefLn{{\tt s=r.sub(s,r,c)}                }{replace {\tt c} counts of {\tt s} with {\tt r}}
\RefLn{{\tt (s,n)=r.subn(s,r,c)}           }{{\tt n} is number of replacements             }
\RefLn{{\tt s=re.escape(s)}                }{escape all nonalphanumerics                  }
\RefLn{{\tt m.start(g);m.span(g);m.end(g)} }{group-match delimiters                        }
\RefLn{{\tt m.expand(s)}                   }{replace {\tt \bs{}1} etc. with matches        }
\RefLn{{\tt m.group(g); m.group("name")}   }{matched group no.~{\tt g}                     }
\RefLn{{\tt m.groups()}                    }{list of groups                                }
\RefLn{{\tt m.groupdict()}                 }{dict of named groups                          }



\section{Basic Syntax}

\RefLn{{\tt if {\it expr}: {\it statements}}         }{conditional                }
\RefLn{{\tt elif {\it expr}: {\it statements}}       }{else if                    }
\RefLn{{\tt else: {\it statements}}                  }{conditional else           }
\RefLn{{\tt if a is b : ...}                         }{object identity            }
\RefLn{{\tt if a == 1}                               }{value identity             }
\RefLn{{\tt while {\it expr}: {\it statements}}      }{while loop                 }
\RefLn{{\tt else: {\it statements}}                  }{while-else (on normal exit)}
\RefLn{{\tt while True: ... if {\it cond}: break}    }{do\dots while equivalent   }
\RefLn{{\tt for item in {\it iter}: {\it statements}}}{for-loop                   }
\RefLn{{\tt else: {\it statements}}                  }{for-else (when items exhausted)}
\RefLn{{\tt for key,value in d.items():...}          }{multiple identifiers       }
\RefLn{{\tt break, continue}                         }{end loop/jump to next      }
\RefLn{{\tt print "hello world",}                    }{print without newline      }
\RefLn{{\tt [ {\it expr} for x in {\it seq} {\it lc} ]}}{list comprehension}
\RefLn{{\tt {\it lc}: for x in {\it seq}} or {\tt if {\it expr}} }{with lc-clauses   }
\RefLn{{\tt pass}                                    }{empty statement}
\RefLn{{\tt def f(params): {\it statements}}         }{function definition}
\RefLn{{\tt def f(x, y=0): return x+y}               }{optional parameter}
\RefLn{{\tt def f(*a1, **a2): {\it statements}}      }{additional list of unnamed, dict of named paramters}
\RefLn{{\tt def f(): f.variable = 1 ...}             }{function attribute}
\RefLn{{\tt return {\it expression}}                 }{return from function}
\RefLn{{\tt yield {\it expression}}                  }{make function a generator}
\RefLn{{\tt f(1,1), f(2), f(y=3, x=4)}               }{function calls}
\RefLn{{\tt global v}                                }{bind to global variable}

\RefLn{
\starttyping
def make_adder_2(a):
    def add(b): return a+b
    return add
\stoptyping}                                          {closure}

\RefLn{{\tt lambda x: x+a}                 }{lambda expression              }
\RefLn{{\tt compile(str,filename,kind)}    }{compile {\tt str} into code object}
\RefLn{{\tt eval(expr,globals,locals)}     }{evaluate expression            }
\RefLn{{\tt exec code in gldict, lcdict}   }{compile and execute code       }
\RefLn{{\tt execfile(file,globals,locals)} }{execute file                   }
\RefLn{{\tt raw\_input(prompt)}            }{input from stdin               }
\RefLn{{\tt input(prompt)}                 }{input and evaluate             }


\section{Object Orientation and Modules}
\RefLn{{\tt import module as alias}            }{import module                }
\RefLn{{\tt from module import name1,name2}    }{load into own namespace}
\RefLn{{\tt from \_\_future\_\_ import *}      }{activate all new features    }
\RefLn{{\tt reload module}                     }{reinitialize module          }
\RefLn{{\tt module.\_\_all\_\_}                }{exported attributes          }
\RefLn{{\tt module.\_\_name\_\_}               }{module name / {\tt \_\_main\_\_}}
\RefLn{{\tt module.\_\_dict\_\_}               }{module namespace             }
\RefLn{{\tt \_\_import\_\_("name",glb,loc,fl)} }{import module by name        }

\CM
\starttyping
class name (superclass,...):
    data = value
    def method(self,...): ...
    def __init__(self, x):
        Super.__init__(self)
        self.member = x
    def __del__(self): ...
\stoptyping \\
class definition               \crlf
shared class data              \crlf
methods                        \crlf
constructor                    \crlf
call superclass constructor    \crlf
per-instance data              \crlf
destructor \\

\RefLn{{\tt \_\_str\_\_, \_\_len\_\_, \_\_cmp\_\_,\_\_}  }{some operator overloaders }
\RefLn{{\tt \_\_iter\_\_(self): return self}   }{use next method for iterator        }
\RefLn{{\tt \_\_call\_\_}                      }{call interceptor                    }
\RefLn{{\tt \_\_dict\_\_}                      }{instance-attribute dictionary       }
\RefLn{{\tt \_\_getattr\_\_(self, name), }     }{get an unknown attribute            }
\RefLn{{\tt \_\_setattr\_\_(self, name, value)}}{set any attribute                   }
\RefLn{{\tt callable(object)}                  }{1 if callable, 0 otherwise          }
\RefLn{{\tt delattr(object, "name")}           }{delete {\tt name} from object       }
\RefLn{{\tt del(object)}                       }{unreference object/var              }
\RefLn{{\tt dir(object)}                       }{list of attr. in object    }
\RefLn{{\tt getattr(object, "name", def)}      }{get name-attr. from object          }
\RefLn{{\tt hasattr(object, "name")}           }{check if object has attr.           }
\RefLn{{\tt hash(object)}                      }{return hash for object              }
\RefLn{{\tt id(object)}                        }{unique int (mem address)        }
\RefLn{{\tt isinstance(object, classOrType)}   }{check for type                      }
\RefLn{{\tt issubclass(class1, class2)}        }{class2 subclass of class1?          }
\RefLn{{\tt iter(object, sentinel)}            }{return iterator for object          }
\RefLn{{\tt locals()}                          }{dict of local vars of caller        }
\RefLn{{\tt repr(object), str(object)}         }{return string-representation        }
\RefLn{{\tt vars(object)}                      }{return {\tt \_\_dict\_\_}           }
\RefLn{{\tt None}                              }{the NULL  object                    }
\RefLn{{\tt if \_\_name\_\_ == "\_\_main\_\_":}}{make modul executable               }



\section{Exception Handling}
\RefLn{{\tt try: ...}                        }{Try-block                    }
\RefLn{{\tt except ExceptionName:}           }{catch exception              }
\CM
\starttyping
except (Ex1, ...), dat:
    print data
    raise
\stoptyping \\
                                             multiple, with data  \crlf
                                             exception handling   \crlf
                                             pass up (re-raise) exception \\
\RefLn{{\tt else: ...}                     }{if no exception occured     }
\RefLn{{\tt finally: ...}                  }{in any case                 }
\RefLn{{\tt assert expression}             }{debug assertion}
\RefLn{{\tt class MyExcept(Exception): ...}}{define user exception}
\RefLn{{\tt raise MyExcept(data)}          }{raise user exception}



\section{System Interaction}

\RefLn{{\tt sys.path}                        }{module search path           }
\RefLn{{\tt sys.platform}                    }{operating system             }
\RefLn{{\tt sys.stdout, stdin, stderr}       }{standard input/output/error  }
\RefLn{{\tt sys.argv[1:]}                    }{command line parameters      }
\RefLn{{\tt os.system(cmd)}                  }{system call                  }
\RefLn{{\tt os.startfile(f)}                 }{open file with assoc.\ prog  }
\RefLn{{\tt os.popen(cmd, r\textbar{}w, bufsize)} }{open pipe (file object) }
\RefLn{{\tt os.popen2(cmd, bufsize, b\textbar{}t)}}{(stdin, stdout) fileobjects  }
\RefLn{{\tt os.popen3(cmd, bufsize, b\textbar{}t)}}{(stdin, stdout,stderr)  }
\RefLn{{\tt os.environ['VAR']; os.putenv[]}  }{read/write environment vars  }
\RefLn{{\tt glob.glob('*.txt')}              }{wildcard search              }

{\bf Filesystem Operations}

\startalignment[flushleft, nothyphenated]
{\it os module:} {\tt access, chdir, chmod, chroot, getcwd, getenv, listdir,
mkdir, remove, unlink, removedirs, rename, rmdir, pipe, ...}

{\it shutil module:}  {\tt copy, copy2, copyfile, copyfileobj, copymode,
copystat, copytree, rmtree}

{\it os.path module:} {\tt abspath, altsep, basename, commonprefix, curdir,
defpath, dirname, exists, expanduser, expandvar, extsep, get[acm]time,
getsize, isabs, isdir, isfile, islink, ismout, join, lexists, normcase,
normpath, pardir, pathsep, realpath, samefile, sameopenfile, samestat, sep,
split, splitdrive, splitext, stat, walk}
\stopalignment

{\it command line argument parsing:}
\starttyping
restlist, opts = \
  getopt.getopt(sys.argv[l:],\
    "s:oh",\
    ["spam=", "other", "help"])
for o, a in opts:
    if o in ("-s", "--lol"): spam = a
    if o in ("-h", "--help"): show_help()
\stoptyping

\section{Input/Output}
\RefLn{{\tt f=codecs.open(if,"rb","utf-8")}}{open file with encoding}
\RefLn{{\tt file=open(infilename, "wb")}   }{open file without encoding}
\RefLn{{\tt codecs.EncodedFile(...)}       }{wrap file into encoding}
\RefLn{{\tt r, w, a, r+}                   }{read/write/append/random}
\RefLn{{\tt rb, wb, ab, r+b}               }{modes w/o eol conversion}
\RefLn{{\tt file.read(N)}                  }{{\tt N} bytes ( entire file if no {\tt N} )}
\RefLn{{\tt file.readline()}               }{the next linestring}
\RefLn{{\tt file.readlines()}              }{list of linestring}
\RefLn{{\tt file.write(string)}            }{write string to file}
\RefLn{{\tt file.writelines(list)}         }{write list of linestrings}
\RefLn{{\tt file.close()}                  }{close file}
\RefLn{{\tt file.tell()}                   }{current file position}
\RefLn{{\tt file.seek(offset, whence)}     }{jump to file position}
\RefLn{{\tt os.truncate(size)}             }{limit output to size}
\RefLn{{\tt os.tmpfile()}                  }{open anon temporary file}
\RefLn{{\tt pickle.dump(x, file)}          }{make object persistent}
\RefLn{{\tt x = pickle.load(file)}         }{load object from file}


\section{Standard Library (almost complete)}

\startalignment[flushleft, nothyphenated]
{\bf String Services:}
{\tt string, re, struct, difflib, StringIO, cStringIO, textwrap, codecs,
unicodedata, stringprep, fpformat}

{\bf File/Directory Access:}
{\tt os.path, fileinput, stat, statvfs, filecmp, tempfile, glob, fnmatch,
linecache, shutil, dircache}

{\bf Generic OS services:}
{\tt os, time, optparse, getopt, logging, getpass, curses, platform, errno,
ctypes}

{\bf Optional OS services:}
{\tt select, thread, threading, dummy\_thread, dummy\_threading, mmap, readline,
rlcompleter}

{\bf Data Types:}
{\tt datetime, calendar, collections, heapq, bisect, array, sets, sched, mutex,
Queue, weakref, UserDict, UserList, UserString, types, new, copy, pprint, repr}

{\bf Numeric and Math Modules:}
{\tt math, cmath, decimal, random, itertools, functools, operator}

{\bf Internet Data Handling:}
{\tt email, mailcap, mailbox, mhlib, mimetools, mimetypes, MimeWriter, mimify,
multifile, rfc822, base64, binhex, binascii, quopri, uu}

{\bf Structured Markup Processing Tools:}
{\tt HTMLParser, sgmllib, htmllib, htmlentitydefs, xml.parsers.expat,
xml.dom.*, xml.sax.*, xml.etree.ElementTree}

{\bf File Formats:}
{\tt csv, ConfigParser, robotparser, netrc, xdrlib}

{\bf Crypto Services:}
{\tt hashlib, hmac, md5, sha}

{\bf Compression:}
{\tt zlib, gzip, bz2, zipfile, tarfile}

{\bf Persistence:}
{\tt pickle, cPickle, copy\_reg, shelve, marshal, anydbm, whichdb, dbm, gdbm,
dbhash, bsddb, dumbdbm, sqlite3}

{\bf Unix specific:}
{\tt posix, pwd, spwd, grp, crypt, dl, termios, tty, pty, fcntl, posixfile,
resource, nis, syslog, commands}

{\bf IPC/Networking:}
{\tt subprocess, socket, signal, popen2, asyncore, asynchat}

{\bf Internet:}
{\tt webbrowser, cgi, scitb, wsgiref, urllib, httplib, ftplib, imaplib,
nntplib, ...lib, smtpd, uuid, urlparse, SocketServer, ...Server,, cookielib,
Cookie, xmlrpclib}

{\bf Multimedia:}
{\tt audioop, imageop, aifc, sunau, wave, chunk, colorsys, rgbimg, imghdr,
sndhdr, ossaudiodev}

{\bf Tk:}
{\tt Tkinter, Tix, ScrolledText, turtle}

{\bf Internationalization:}
{\tt gettext, locale}

{\bf Program Frameworks:}
{\tt cmd, shlex}

{\bf Development:}
{\tt pydoc, doctest, unittest, test}

{\bf Runtime:}
{\tt sys, warnings, contextlib, atexit, traceback, qc, inspect, site, user,
fpectl}

{\bf Custom Interpreters:}
{\tt code, codeop}

{\bf Restricted Execution:}
{\tt rexec, Bastion}

{\bf Importing:}
{\tt imp, zipimport, pkgutil, modulefinder, runpy}

{\bf Language:}
{\tt parser, symbol, token, keyword, tokenize, tabnanny, pyclbr, py\_compile,
compileall, dis, pickletools, distutils}

{\bf Windows:}
{\tt msilib, msvcrt, \_winreq, winsound}

{\bf Misc:}
{\tt formatter}
\stopalignment

\StopRefcard

\stopproduct
