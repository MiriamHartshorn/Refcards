
% VIM Quick Reference Card
% Copyright (c) 2008 Michael Goerz.
% TeX Format

% compile as 'pdftex vimqrc.tex'

% \pdfoutput=1
\pdfpageheight=21cm
\pdfpagewidth=29.7cm

% Font definitions
\font\bigbf=cmbx12
\font\smallrm=cmr8
\font\smalltt=cmtt8
\font\tinyit=cmmi5

\def\title#1{\hfil{\bf #1}\hfil\par\vskip 2pt\hrule}
\def\cm#1#2{{\tt#1}\dotfill#2\par}
\def\cn#1{\hfill$\lfloor$ #1\par}
\def\sect#1{\vskip 0.7cm {\it#1\/}\par}

% Characters definitions
\def\\{\hfil\break}
\def\bs{$\backslash$}
\def\backspace{$\leftarrow$}
\def\ctrl{{\rm\char94}\kern-1pt}
\def\enter{$\hookleftarrow$}
\def\or{\thinspace{\tinyit{or}}\thinspace}
\def\key#1{$\langle${\rm{\it#1\/}}$\rangle$}
\def\rapos{\char125}
\def\lapos{\char123}
\def\bs{\char92}
\def\tild{\char126}

% Three columns definitions
\parindent 0pt
\nopagenumbers
\hoffset=-1.56cm
\voffset=-1.54cm
\newdimen\fullhsize
\fullhsize=27.9cm
\hsize=8.5cm
\vsize=19cm
\def\fullline{\hbox to\fullhsize}
\let\lr=L
\newbox\leftcolumn
\newbox\midcolumn
\output={
  \if L\lr
    \global\setbox\leftcolumn=\columnbox
    \global\let\lr=M
  \else\if M\lr
    \global\setbox\midcolumn=\columnbox
    \global\let\lr=R
  \else
    \tripleformat
    \global\let\lr=L
  \fi\fi
  \ifnum\outputpenalty>-20000
  \else
    \dosupereject
  \fi}
\def\tripleformat{
  \shipout\vbox{\fullline{\box\leftcolumn\hfil\box\midcolumn\hfil\columnbox}}
  \advancepageno}
\def\columnbox{\leftline{\pagebody}}

% Card content
% Header
%\hrule\vskip 3pt
\title{VIM QUICK REFERENCE CARD}

\vskip 0.5cm
\cm{:viusage}{Show a summary of all commands}

\sect{Movements}
\cm{h l k j}{character left, right; line up, down}
\cm{b w}{word/token left, right}
\cm{ge e}{end of word/token left, right}
\cm{\lapos\ \rapos}{beginning of previous, next paragraph}
\cm{( )}{beginning of previous, next sentence}
\cm{0 \^\ \$}{beginning, first, last character of line}
\cm{$n$G $n$gg}{line $n$, default the last, first}
\cm{$n|$}{column $n$ of current line}
\cm{\%}{match of next brace, bracket, comment, {\tt\#define}}
\cm{- +}{line up, down on first non-blank character}
\cm{B W}{space-separated word left, right}
\cm{gE E}{end of space-separated word left, right}
\cm{g0 gm}{beginning, middle of {\it screen\/} line}
\cm{g\^\ g\$}{first, last character of {\it screen\/} line}
\cm{f$c$ F$c$}{next, previous occurence of character $c$}
\cm{t$c$ T$c$}{before next, previous occurence of $c$}


\sect{Insertion \& Replace $\to$ insert mode}
\cm{i a}{insert before, after cursor}
\cm{I A}{insert at beginning, end of line}
\cm{gI}{insert text in first column}
\cm{o O}{open a new line below, above the current line}
\cm{r$c$}{replace character under cursor with $c$}
\cm{gr$c$}{like {\tt r}, but without affecting layout}
\cm{R}{replace characters starting at the cursor}
\cm{gR}{like {\tt R}, but without affecting layout}
\cm{c$m$}{change text of movement command $m$}
\cm{cc\or S}{change current line}
\cm{C}{change to the end of line}

\sect{Deletion}
\cm{x X}{delete character under, before cursor}
\cm{d$m$}{delete text of movement command $m$}
\cm{dd D}{delete current line, to the end of line}
\cm{J gJ}{join current line with next, without space}
\cm{:$r$d\enter}{delete range $r$ lines}
\cm{:$r$d$x$\enter}{delete range $r$ lines into register $x$}

\vskip 1cm
\sect{Insert Mode}
\cm{\ctrl V$c$ \ctrl V$n$}{insert char $c$ literally, decimal value $n$}
% \cm{\ctrl V$n$}{insert decimal value of character}
\cm{\ctrl A}{insert previously inserted text}
\cm{\ctrl @}{same as {\tt\ctrl A} and stop insert $\to$ command mode}
\cm{\ctrl R$x$ \ctrl R\ctrl R$x$}{insert content of register $x$, literally}
\cm{\ctrl N \ctrl P}{text completion before, after cursor}
\cm{\ctrl W}{delete word before cursor}
\cm{\ctrl U}{delete all inserted character in current line}
\cm{\ctrl D \ctrl T}{shift left, right one shift width}
\cm{\ctrl K$c_1$$c_2$\or $c_1$\kern-1pt\backspace$c_2$}{enter digraph $\{c_1,c_2\}$}
\cm{\ctrl O$c$}{execute $c$ in temporary command mode}
\cm{\ctrl X\ctrl E \ctrl X\ctrl Y}{scroll up, down}
\cm{\key{esc}\or \ctrl[}{abandon edition $\to$ command mode}

\vskip 0.4cm
\sect{Search \& Substitution}
\cm{/$s$\enter\ ?$s$\enter}{search forward, backward for $s$}
\cm{/$s$/$o$\enter\ ?$s$?$o$\enter}{search fwd, bwd for $s$ with offset $o$}
\cm{n\or /\enter}{repeat forward last search}
\cm{N\or ?\enter}{repeat backward last search}
\cm{\# *}{search backward, forward for word under cursor}
\cm{g\# g*}{same, but also find partial matches}
\cm{gd gD}{local, global definition of symbol under cursor}
\cm{:$r$s/$f$/$t$/$x$\enter}{substitute $f$ by $t$ in range $r$}
\cn{$x:$ {\tt g}---all occurrences, {\tt c}---confirm changes}
\cm{:$r$s $x$\enter}{repeat substitution with new $r$ \& $x$}
\cm{:$r$g/$p$/$c$\enter}{execute {\it Ex\/} $c$ on range $r$ where $p$ matches}

\vskip 0.4cm
\sect{Standard Mode Formatting/Filtering}
Leave out $m$ for visual mode commands \\
\cm{gq$m$ gqgq}{format movement $m$/current paragraph}
\cm{:$r$ce $w$\enter}{center lines in range $r$ to width $w$}
\cm{:$r$le $i$\enter}{left align lines in range $r$ with indent $i$}
\cm{:$r$ri $w$\enter}{right align lines in range $r$ to width $w$}
\cm{!$m$$c$\enter}{filter lines of movement $m$ through command $c$}
\cm{$n$!!$c$\enter}{filter $n$ lines through command $c$}
\cm{:$r$!$c$\enter}{filter range $r$ lines through command $c$}
\cm{\tild}{switch case and advance cursor}
\cm{g\tild{$m$}}{switch case of movement command $m$}
\cm{gu$m$ gU$m$}{lowercase, uppercase text of movement $m$}
\cm{$<$$m$ $>$$m$}{shift left, right text of movement $m$}
\cm{$n$$<$\kern-3pt$<$ $n$$>$\kern-3pt$>$}{shift $n$ lines left, right}


\vskip 0.8cm
\sect{Visual Mode}
\cm{v V \ctrl V}{start/stop highlighting characters, lines, block}
\cm{o}{exchange cursor position with start of highlighting}
\cm{gv}{start highlighting on previous visual area}
\cm{aw as ap}{select a word, a sentence, a paragraph}
\cm{ab aB}{select a block ( ), a block {\tt\lapos} {\tt\rapos}}
\cm{$n\hskip -0.3em>$ $n\hskip -0.3em<$ $=$}{indent/unindent $n$ levels, reindent}

\sect{Undoing, Repeating \& Registers}
\cm{u U}{undo last command, restore last changed line}
\cm{.\thinspace\thinspace\ctrl R}{repeat last changes, redo last undo}
\cm{$n$.\ }{repeat last changes with count replaced by $n$}
\cm{q$c$ q$C$}{record, append typed characters in register $c$}
\cm{q}{stop recording}
\cm{@$c$}{execute the content of register $c$}
\cm{@@}{repeat previous {\tt @} command}
\cm{:@$c$\enter}{execute register $c$ as an {\it Ex\/} command}


\sect{Copying}
\cm{"$x$}{use register $x$ for next delete, yank, put}
\cm{:reg\enter}{show the content of all registers}
\cm{:reg $x$\enter}{show the content of registers $x$}
\cm{y$m$}{yank the text of movement command $m$}
\cm{yy\or Y}{yank current line into register}
\cm{p P}{put register after, before cursor position}
\cm{]p [p}{like {\tt p}, {\tt P} with indent adjusted}
\cm{gp gP}{like {\tt p}, {\tt P} leaving cursor after new text}



\sect{Patterns (differences to Perl)}
\cm{:help pattern\enter}{show complete help on patterns}
\cm{:help perl-patterns\enter}{show comparison with perl}
\cm{\bs$<$ \bs$>$}{start, end of word}
\cm{\bs i \bs k \bs I \bs K}{an identifier, keyword; excl. digits}
\cm{\bs f \bs p \bs F \bs P}{a file name, printable char.; excl. digits}
\cm{\bs e \bs t \bs r \bs b}{\key{esc}, \key{tab}, \key{\enter}, \key{$\gets$}}
\cm{\bs = * \bs +}{match $0..1$, $0..\infty$, $1..\infty$ of preceding atoms}
\cm{\bs$\{-\}$}{non-greedy match}
\cm{\bs$|$}{separate two branches ($\equiv$ {\it or\/})}
\cm{\bs( \bs)}{group patterns into an atom}
\cm{\bs \& \bs{}1}{the whole matched pattern, $1^{st}$ {\tt()} group}
\cm{\bs u \bs l}{upper, lowercase character}
\cm{\bs c \bs C}{ignore, match case on next pattern}
\cm{\bs \%x}{match hex character}
\cm{\bs @= \bs @!}{\tt (?=pattern) (?!pattern)\rm}
\cm{\bs @$<$= \bs @$<$!}{\tt (?$<$=pattern) (?$<$!pattern)\rm}
\cm{\bs @$>$ }{\tt (?$>$pattern)\rm}
\cm{\bs\_\^{} \bs\_\$}{start-of-line/end-of-line, anywhere in pattern}
\cm{\bs\_. }{any single char, including end-of-line}
\cm{\bs zs \bs ze}{set start/end of pattern}
\cm{\bs \%\^{} \bs\%\$}{match start/end of file}
\cm{\bs\% V}{match inside visual area}
\cm{\bs\tt'\rm m}{match with position of mark m}
\cm{\bs\%(\bs)}{unnamed grouping}
\cm{\bs\_$[$ $]$}{collection with end-of-line included}
\cm{\bs\%$[$ $]$}{sequence of optionally matched atoms}

\sect{Spell Checking}
\cm{:set spell spelllang=de\_20\enter}{activate spellcheck}
\cm{$]$s}{next misspelled word}
\cm{zg zG}{add good word (to internal word list)}
\cm{zw zW}{mark bad word (to internal word list)}
\cm{z=}{suggest corrections}

\sect{Marks and Motions}
\cm{m$c$}{mark current position with mark $c\in[a..Z]$}
\cm{`$c$ `$C$}{go to mark $c$ in current, $C$ in any file}
\cm{`$0..9$}{go to last exit position}
\cm{`\/`  `\/"}{go to position before jump, at last edit}
\cm{`[ `]}{go to start, end of previously operated text}
\cm{:marks\enter}{print the active marks list}
\cm{:jumps\enter}{print the jump list}
\cm{$n$\ctrl O}{go to $n^{th}$ older position in jump list}
\cm{$n$\ctrl I}{go to $n^{th}$ newer position in jump list}

\sect{Tags}
\cm{:ta $t$\enter}{jump to tag $t$}
\cm{:$n$ta\enter}{jump to $n^{th}$ newer tag in list}
\cm{\ctrl ] \ctrl T}{jump to the tag under cursor, return from tag}
\cm{:ts $t$\enter}{list matching tags and select one for jump}
\cm{:tj $t$\enter}{jump to tag or select one if multiple matches}
\cm{:tags\enter}{print tag list}
\cm{:$n$po\enter\ :$n$\ctrl T\enter}{jump back from, to $n^{th}$ older tag}
\cm{:tl\enter}{jump to last matching tag}
\cm{\ctrl W\rapos\ :pt $t$\enter}{preview tag under cursor, tag $t$}
\cm{\ctrl W]}{split window and show tag under cursor}
\cm{\ctrl Wz\or :pc\enter}{close tag preview window}

\sect{Multiple Files / Buffers (\enter)}
\cm{:tab ball}{show buffer tablist}
\cm{:buffers}{show list of buffers}
\cm{:buffer n}{switch to buffer n}
\cm{:badd f.txt}{load file into new buffer}
\cm{:bdelete n}{delete buffer n (also with filename)}
\cm{:bnext :bprev :bfirst :blast}{buffer movement}



\sect{Scrolling \& Multi-Windowing}
\cm{\ctrl D \ctrl U}{scroll half a page up, down}
\cm{\ctrl F \ctrl B}{scroll page up, down}
\cm{zt zz zb}{current line to top, center, bottom of win.}
\cm{zh zl}{scroll one character to the right, left}
\cm{zH zL}{scroll half a screen to the right, left}
\cm{:split\enter{} :vsplit\enter}{split window in two (vert.)}
\cm{:new\enter{} :vnew\enter}{create new empty windowi (vert.)}
\cm{:on\enter}{make current window one on screen}
\cm{\ctrl Wj \ctrl Wk}{move to window below, above}
\cm{\ctrl Ww \ctrl W\ctrl W}{move to window below, above (wrap)}
\cm{\ctrl W$n$+ \ctrl W$n$-}{Increase/decrease window size by $n$ lines}
\cm{\ctrl W$n>$ \ctrl W$n<$}{Increase/decrease window width}

\sect{Misc Ex Commands (\enter)}
\cm{:help holy-grail}{show all Ex commands}
\cm{:e $f$}{edit file $f$, reload current file if no $f$}
\cm{:$r$w $f$}{write range $r$ to file $f$ (current file if no $f$)}
\cm{:$r$w$>$\kern-3pt$>$$f$}{append range $r$ to file $f$}
\cm{:q :q!}{quit and confirm, quit and discard changes}
\cm{:wq\or :x\or ZZ}{write to current file and exit}
\cm{:r $f$}{insert content of file $f$ below cursor}
\cm{:r!\ $c$}{insert output of command $c$ below cursor}
\cm{:$r$c\ $a$ :$r$m\ $a$}{copy, move range $r$ below line $a$}

\sect{Ex Ranges}
\cm{, ;\ }{separates two lines numbers, set to first line}
\cm{$n$}{an absolute line number $n$}
\cm{.\thinspace\thinspace\thinspace\$}{the current line, the last line in file}
\cm{\% *}{entire file, visual area}
\cm{'$t$}{position of mark $t$}
\cm{/$p$/ ?$p$?}{the next, previous line where $p$ matches}
\cm{+$n$ -$n$}{$+n$, $-n$ to the preceding line number}

\sect{Folding}
\cm{:set fmt=indent\enter}{indent-foldmethod}
\cm{zf$m$}{create fold of movement $m$}
\cm{:$r$fo}{create fold for range $r$}
\cm{zd zE}{delete fold at cursor, all in window}
\cm{zo zc zO zC}{open, close one fold; recursively}
\cm{[z ]z}{move to start, end of current open fold}
\cm{zj zk}{move down, up to start, end of next fold}
\cm{zm zM}{fold more, close all folds}
\cm{zr zR}{fold less, open all folds}
\cm{zn zN zi}{fold non, fold normal, invert folding}
\cm{:set foldcolumn=4\enter}{show foldcolumn}



\sect{Compiling}
\cm{:compiler $c$}{set/show compiler plugins}
\cm{:make\enter}{run {\tt makeprg}, jump to first error}
\cm{:cope\enter}{navigate errors from make}
\cm{:cn\enter\ :cp\enter}{display the next, previous error}
\cm{:cl\enter\ :cf\enter}{list all errors, read errors from file}


\sect{Miscellaneous}
\cm{:sh\enter\ :!$c$\enter}{start shell, execute command $c$ in shell}
\cm{K}{run {\tt keywordprg} (man) on word under cursor}
\cm{\ctrl L}{redraw screen}
\cm{\ctrl G}{show cursor column, line, and character position}
\cm{:set cuc\enter}{show cursor column visually}
\cm{ga}{show A{\smallrm SCII} value of character under cursor}
\cm{gf}{open file which filename is under cursor}
\cm{:mkview $[f]$}{save view configuration [to file $f$]}
\cm{:loadview $[f]$}{load view configuration [from file $f$]}
\cm{:set ff=dos\enter}{convert file to dos eol format} 
\cm{:e ++ff=unix\enter}{reopen file in unix eol format}
\cm{:set hlsearch\enter}{highlight searches}
\cm{:$r$hardcopy > file.ps}{print range to ps file}


% Footer
\vfill \hrule\smallskip
{\smallrm This card may be freely distributed under
the terms of the GNU general public licence ---
Copyright \copyright\ {\oldstyle 2008} by Michael Goerz. 
{\smalltt http://www.physik.fu-berlin.de/\tild{goerz/}}. Based on original by 
Laurent Gr\'egoire  ({\smalltt http://tnerual.eriogerg.free.fr/})}

% Ending
\supereject
\if L\lr \else\null\vfill\eject\fi
\if L\lr \else\null\vfill\eject\fi
\bye

% EOF
